<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Docker | Teracy's Blog]]></title>
  <link href="http://blog.teracy.com/tags/docker/atom.xml" rel="self"/>
  <link href="http://blog.teracy.com/"/>
  <updated>2017-09-29T03:48:04+00:00</updated>
  <id>http://blog.teracy.com/</id>
  <author>
    <name><![CDATA[Teracy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to use Docker in Docker (DinD) and Docker outside of Docker (DooD) for local CI testing]]></title>
    <link href="http://blog.teracy.com/2017/09/11/how-to-use-docker-in-docker-dind-and-docker-outside-of-docker-dood-for-local-ci-testing/"/>
    <updated>2017-09-11T08:10:00+00:00</updated>
    <id>http://blog.teracy.com/2017/09/11/how-to-use-docker-in-docker-dind-and-docker-outside-of-docker-dood-for-local-ci-testing</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2017/09/11/spintop-dind.jpg" title="Docker in Docker" >
Credit: <a href="https://github.com/jpetazzo/dind">https://github.com/jpetazzo/dind</a></p>

<p>Although running Docker inside Docker (DinD) or Docker outside of Docker (DooD) is generally not
recommended, there are some legitimate use cases, such as development of Docker itself or for local
CI testing. And in this blog post, I&rsquo;m going to show you how to use DinD or DooD for local CI testing
as it&rsquo;s a very typical use case for local DevOps.</p>

<!-- more -->


<h2>The differences between DinD and DooD?</h2>

<p>DinD is the opposite of DooD.</p>

<p>DinD includes a whole Docker installation inside of it.</p>

<p>DooD uses its underlying host&rsquo;s Docker installation by bind-mounting the Docker socket.</p>

<p>Obviously, DooD should be faster because we can leverage its caching mechanism, and DinD should be
cleaner. DinD should support parallel running but DooD does not, or at least, not very reliable
with my observation. If you want to conduct the clean testing, use DinD. If you want to conduct the
faster testing, use DooD.</p>

<p>DooD is simpler to use than DinD.</p>

<p>And if you want to test with different versions of <code>docker</code>, <code>docker-compose</code>, use DinD and DooD.</p>

<h2>Local CI testing with DinD</h2>

<p>You can use <a href="https://hub.docker.com/r/library/docker/">https://hub.docker.com/r/library/docker/</a> for local testing, however, it&rsquo;s <code>alpine</code> image
which is not very suitable for local CI testing since it is not the default travis-ci environment.
We should use Ubuntu for executing CI scripts on all the CI systems (gitlab, drone, etc.) because we
can port the CI scripts easily between these CI systems.</p>

<p>That is the reason why we build <code>teracy/ubuntu</code> Docker images to be used with DinD, you can check out
the project here: <a href="https://github.com/teracyhq/docker-files/tree/master/ubuntu">https://github.com/teracyhq/docker-files/tree/master/ubuntu</a> and the built Docker
images here: <a href="https://hub.docker.com/r/teracy/ubuntu/tags/">https://hub.docker.com/r/teracy/ubuntu/tags/</a></p>

<p>We also have <code>docker-compose</code> installed to the <code>teracy/ubuntu</code> Docker images for faster testing
with it.</p>

<p>Let&rsquo;s see how it works:</p>

<script type="text/javascript" src="https://asciinema.org/a/137135.js" id="asciicast-137135" async></script>


<p>The commands from the above video:</p>

<p>```bash
$ docker run &mdash;privileged &mdash;name df-docker -d docker:17.06.0-dind # start DinD container</p>

<p>$ docker run &mdash;rm -it &mdash;link df-docker:docker docker:17.06.0 sh # run docker image (Alpine)</p>

<h1>docker version</h1>

<h1>docker-compose &mdash;version # no docker-compose</h1>

<p>$ docker run &mdash;rm -it ubuntu bash # run Ubuntu image within the Docker Alpine container</p>

<h1>uname -a</h1>

<h1>exit</h1>

<h1>uname -a</h1>

<h1>exit</h1>

<p>$ docker run &mdash;rm -it &mdash;link df-docker:docker teracy/ubuntu:16.04-dind-17.06.0-ce bash # run Ubuntu image</p>

<h1>docker version</h1>

<h1>docker-compose version</h1>

<p>$ docker run &mdash;rm -it alpine sh # run Alpine image with the Docker Ubuntu container</p>

<h1>uname -a</h1>

<h1>exit</h1>

<h1>uname -a</h1>

<h1>exit</h1>

<p>```</p>

<h2>Local CI testing with DooD</h2>

<p>Let&rsquo;s see how it works:</p>

<script type="text/javascript" src="https://asciinema.org/a/137139.js" id="asciicast-137139" async></script>


<p>The commands from the above video:</p>

<p>```
$ docker run &mdash;rm -it -v /var/run/docker.sock:/var/run/docker.sock docker sh # start DooD container</p>

<h1>docker version</h1>

<h1>docker-compose &mdash;version # no docker-compose</h1>

<p>$ docker run &mdash;rm -it ubuntu bash # run Ubuntu image within the Docker Alpine container</p>

<h1>cat /etc/lsb-release</h1>

<h1>exit</h1>

<h1>cat /etc/alpine-release</h1>

<h1>exit</h1>

<p>$ docker run &mdash;rm -it -v /var/run/docker.sock:/var/run/docker.sock teracy/ubuntu:16.04-dind-17.06.0-ce bash # start DooD container</p>

<h1>docker version</h1>

<h1>docker-compose version</h1>

<h1>docker run &mdash;rm -it alpine sh # run Alpine image with the Docker Ubuntu container</h1>

<h1>cat /etc/alpine-release</h1>

<h1>exit</h1>

<h1>cat /etc/lsb-release</h1>

<h1>exit</h1>

<p>```</p>

<h2>Volume mounting</h2>

<p>Volume mounting is a bit tricky, you must understand the underlying mechanism of its to get it work.
Basically, you need to make sure the mounting path from the running containers must be the same as the
DinD containers or DooD containers.</p>

<p>Let&rsquo;s see how volume mounting works with DinD:</p>

<script type="text/javascript" src="https://asciinema.org/a/137150.js" id="asciicast-137150" async></script>


<p>The commands from the above video:</p>

<p>```bash</p>

<h1>volume mount with DinD</h1>

<p>$ pwd
$ ls
$ docker run &mdash;privileged &mdash;name df-docker -d -v $(pwd):$(pwd) -w $(pwd) docker:17.06.0-dind # start DinD container
$ docker run &mdash;rm -it &mdash;link df-docker:docker -v $(pwd):$(pwd) -w $(pwd) teracy/ubuntu:16.04-dind-17.06.0-ce bash</p>

<h1>ls</h1>

<h1>docker run &mdash;rm -it -v $(pwd):/opt/app -w /opt/app ubuntu bash</h1>

<h1>ls</h1>

<p>```</p>

<p>Let&rsquo;s see how volume mounting works with DooD:</p>

<script type="text/javascript" src="https://asciinema.org/a/137152.js" id="asciicast-137152" async></script>


<p>The commands from the above video:</p>

<p>```bash</p>

<h1>volume mount with DooD</h1>

<p>$ pwd
$ ls
$ docker run &mdash;rm -it -v /var/run/docker.sock:/var/run/docker.sock -v $(pwd):/$(pwd) -w $(pwd) teracy/ubuntu:16.04-dind-17.06.0-ce bash # start DooD container</p>

<h1>ls</h1>

<h1>docker run &mdash;rm -it -v $(pwd):/opt/app -w /opt/app ubuntu bash</h1>

<h1>ls</h1>

<p>```</p>

<h2>Local CI Testing with a real project</h2>

<p>Let&rsquo;s see how we can conduct a local CI testing with the <a href="https://github.com/teracyhq/docker-files">https://github.com/teracyhq/docker-files</a> project.</p>

<p>Let&rsquo;s dive into the .travis.yml file <a href="https://github.com/teracyhq/docker-files/blob/master/.travis.yml">https://github.com/teracyhq/docker-files/blob/master/.travis.yml</a>
to test the following scripts:</p>

<p>```yml
before_install:</p>

<h1>install the latest docker and docker-compose versions</h1>

<ul>
<li>sudo apt-get remove docker docker-engine</li>
<li>sudo curl -sSL <a href="https://get.docker.com/">https://get.docker.com/</a> | sh</li>
<li>sudo rm /usr/local/bin/docker-compose

<h1>the latest docker-compose version</h1></li>
<li>export DOCKER_COMPOSE_VERSION=$(curl -s <a href="https://api.github.com/repos/docker/compose/releases/latest">https://api.github.com/repos/docker/compose/releases/latest</a> | grep &lsquo;tag_name&rsquo; | cut -d\&ldquo; -f4)</li>
<li>curl -L <a href="https://github.com/docker/compose/releases/download/$">https://github.com/docker/compose/releases/download/$</a>{DOCKER_COMPOSE_VERSION}/docker-compose-<code>uname -s</code>&ndash;<code>uname -m</code> > docker-compose</li>
<li>chmod +x docker-compose</li>
<li>sudo mv docker-compose /usr/local/bin</li>
<li>docker version</li>
<li>docker-compose version
```</li>
</ul>


<p>Let&rsquo;s see how to do local CI testing in action:</p>

<script type="text/javascript" src="https://asciinema.org/a/137314.js" id="asciicast-137314" async></script>


<p>This is just the very first step for basic testing.</p>

<p>Later, we should convert this <code>.travis.yml</code> file into a <code>build.sh</code> one to execute, this is the right way
for local CI testing travis-ci and other similar CI systems.</p>

<p>To do that, please follow <a href="https://github.com/teracyhq/docker-files/issues/42">https://github.com/teracyhq/docker-files/issues/42</a> and I&rsquo;ll update this
section more when it&rsquo;s ready.</p>

<h2>Too many virtualization layers?</h2>

<p>At Teracy, the <code>teracy-dev</code> VM is virtualized on a host machine (and the host machine could be virtualized
from another virtualized machine and so on).</p>

<p>Within the <code>teracy-dev</code> VM, we use DinD. And within a Docker container, we can use Docker to run other
Docker containers and so on.</p>

<p>Yeah, welcome to the world of &ldquo;Inception&rdquo;, let&rsquo;s figure out where you are now :&ndash;)?</p>

<p>Happy hacking!</p>

<h2>References</h2>

<ul>
<li><a href="http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/">http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/</a></li>
<li><a href="https://hub.docker.com/r/library/docker/">https://hub.docker.com/r/library/docker/</a></li>
<li><a href="https://github.com/axltxl/docker-jenkins-dood">https://github.com/axltxl/docker-jenkins-dood</a></li>
<li><a href="https://sreeninet.wordpress.com/2016/12/23/docker-in-docker-and-play-with-docker/">https://sreeninet.wordpress.com/2016/12/23/docker-in-docker-and-play-with-docker/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to set up CI/CD system for Next.js with Docker on gitlab-ci, travis-ci, Heroku and Kubernetes]]></title>
    <link href="http://blog.teracy.com/2017/05/09/how-to-set-up-ci-cd-system-for-next.js-with-docker-on-gitlab-ci-travis-ci-heroku-and-kubernetes/"/>
    <updated>2017-05-09T01:14:00+00:00</updated>
    <id>http://blog.teracy.com/2017/05/09/how-to-set-up-ci-cd-system-for-next.js-with-docker-on-gitlab-ci-travis-ci-heroku-and-kubernetes</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2017/05/09/nextjs-hello-world-travis-ci.png" title="travis-ci builds" ></p>

<p>Setting up a CI/CD (continuous integration/continuous delivery) system for Docker applications to be
deployed on staging and production environment with scalability and high availability is not hard.
It took a while to get it done properly, and today I will show you how to set up that system properly
with a Next.js application as an example. You can apply the same process for all other kinds of
Docker applications. So let&rsquo;s get started.</p>

<!-- more -->


<h1>Prerequisites</h1>

<p>Newcomers to Docker ecosystem can enjoy this tutorial.</p>

<p>Experienced ones to Docker ecosystem can review this for your approach and suggest what we can do for
a better approach.</p>

<p>If you know these systems below, that&rsquo;s great and easier to follow this tutorial:</p>

<ul>
<li>Docker</li>
<li>gitlab-ci, travis-ci as CI/CD system</li>
<li>Heroku as a PaaS (Platform as a Service)</li>
<li>Kubernetes (Production-Grade Container Scheduling and Management)</li>
<li>Helm (The Kubernetes Package Manager)</li>
</ul>


<h1>Getting Started</h1>

<p>First, you need to have Docker installed on your system. To make it easier for all platforms (Linux,
macOS, Windows), we&rsquo;re going to use <code>teracy-dev</code> for local dev environment.</p>

<p>To know why <code>teracy-dev</code>, see the blog <a href="/2016/12/20/teracy-dev-the-only-truly-universal-productive-development-platform-with-docker-on-macos-linux-and-windows/">Teracy-dev &ndash; the Only Truly Universal Productive Development Platform With Docker on macOS, Linux and Windows</a>.</p>

<p>You&rsquo;re not required to use teracy-dev, however, using it should help you follow this tutorial more easily.</p>

<p>We&rsquo;re going to use <a href="https://github.com/acme101/nextjs-hello-world">https://github.com/acme101/nextjs-hello-world</a> as an example project.</p>

<p><code>acme101</code> is a sample github organization which has all the best practices from <code>teracy-dev</code> applied
for organizations, follow it and you can&rsquo;t get lost.</p>

<p><code>nextjs-hello-world</code> is the simplest seed code for Next.js applications with Docker workflow, CI/CD system:</p>

<ul>
<li><p>CI/CD with gitlab-ci: <a href="https://gitlab.com/acme101/nextjs-hello-world/pipelines">https://gitlab.com/acme101/nextjs-hello-world/pipelines</a></p></li>
<li><p>CI/CD with travis-ci: <a href="https://travis-ci.org/acme101/nextjs-hello-world/builds">https://travis-ci.org/acme101/nextjs-hello-world/builds</a></p></li>
<li><p>Auto deployment to Heroku: <a href="https://acme-nextjs-staging.herokuapp.com/">https://acme-nextjs-staging.herokuapp.com/</a></p></li>
<li><p>Auto deployment to GKE (Kubernetes) with terapp.com (A record domain): <a href="https://acme-nextjs-staging.terapp.com/">https://acme-nextjs-staging.terapp.com/</a></p></li>
</ul>


<p>To set up the project on local development:</p>

<ul>
<li><p>Follow: <a href="https://github.com/acme101/dev-setup/blob/master/README.md">https://github.com/acme101/dev-setup/blob/master/README.md</a></p></li>
<li><p>Check out the repo into the <code>acme-dev/workspace</code> directory</p></li>
</ul>


<p>That&rsquo;s it, you&rsquo;re ready to work on the local dev environment.</p>

<h1>Local Dev Environment</h1>

<p>Our development philosophy is this: everything can and should be done on local development with
consistent behaviors between all developers and production deployments.</p>

<p>And Docker helps us with that to create a consistent build-time and run-time environment for all.</p>

<p>Usually, there are 3 modes on local dev for our workflow:</p>

<ul>
<li><p>Dev Mode: developers work on this for new changes, this usually contains development dependencies.</p></li>
<li><p>Prod Mode: developers need to make sure that production Docker image should work on local dev.
This production Docker image, which is different from the one from dev mode, will contain only
the production dependencies, and the runtime environment only.</p>

<p>If developers can only make it work on dev mode, prod mode can break. If prod mode breaks, developers can
check and fix it on local dev. This is really conveninent and time saving.</p></li>
<li><p>Prod Review Mode: we should review the work from others and this mode help us for faster reviewing
process. Basically, everyone&rsquo;s work branch will have the corresponding production Docker image that
we can review it right away on our local dev environment. We don&rsquo;t have to checkout the codes to start
reviewing.</p>

<p>This is helpful for us to set up CI/CD system for reviewing process later: when a pull request is sent,
the CI/CD system should deploy it right away for QA to validate, for example.</p></li>
</ul>


<p>The following is the more details about how to use these modes:</p>

<h2>Dev Mode</h2>

<p>To run dev mode on the current source code.</p>

<p><code>
$ vagrant ssh
$ ws
$ cd nextjs-hello-world
$ docker-compose up -d dev &amp;&amp; docker-compose logs -f dev
</code></p>

<p>Open dev.nextjs.acme.dev (http + https modes) to check it out.</p>

<h2>Prod Mode</h2>

<p>To run prod mode on the current source code.</p>

<p><code>
$ docker-compose run --rm dev yarn run build &amp;&amp; \
  docker-compose -f docker-compose.yml -f docker-compose.prod.yml build prod &amp;&amp; \
  docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d prod
</code></p>

<p>We usually scale at least 2 or more containers, so please scale it on local dev too to make sure scaling should work:</p>

<p><code>
$ docker-compose -f docker-compose.yml -f docker-compose.prod.yml scale prod=2
</code></p>

<p>Open nextjs.acme.dev (http + https modes) to check it out.</p>

<p>Don&rsquo;t forget to remove the container after checking out for cleaning up:</p>

<p><code>
$ docker-compose -f docker-compose.yml -f docker-compose.prod.yml stop prod &amp;&amp; \
  docker-compose -f docker-compose.yml -f docker-compose.prod.yml rm -f prod
</code></p>

<h2>Prod Review Mode</h2>

<p>To review prod mode from different built Docker image.</p>

<p>For example, I need to review the <code>hoatle/nextjs-hello-world:features-1-something</code> Docker image
from @hoatle.</p>

<p><code>
$ export DOCKER_IMAGE_REVIEW=hoatle/nextjs-hello-world:features-1-something &amp;&amp; \
docker-compose -f docker-compose.yml -f docker-compose.review.yml pull review &amp;&amp; \
docker-compose -f docker-compose.yml -f docker-compose.review.yml up -d review
</code></p>

<p>We usually scale at least 2 or more containers, so please scale it on local dev too to make sure scaling should work:</p>

<p><code>
$ docker-compose -f docker-compose.yml -f docker-compose.review.yml scale review=2
</code></p>

<p>Open review.nextjs.acme.dev (http + https modes) to check it out.</p>

<p>Don&rsquo;t forget to remove the containers after checking out for cleaning up:</p>

<p><code>
$ docker-compose -f docker-compose.yml -f docker-compose.review.yml stop review &amp;&amp; \
  docker-compose -f docker-compose.yml -f docker-compose.review.yml rm -f review
</code></p>

<p>That&rsquo;s how we, developers, usually work on local development. And to streamline the work, we need
to deploy the applications on production system.</p>

<p>The <code>docker-compose</code> commands above are rather long, maybe you can create bash files to run more easily,
for example, <code>$ dev.sh start</code>, <code>$ dev.sh stop</code>, <code>$ prod.sh build</code>, <code>$ prod.sh start</code>, <code>$ prod.sh stop</code>,
<code>$ review.sh start &lt;image_for_review&gt;</code> and <code>$ review.sh stop</code>.</p>

<h1>Production System</h1>

<p>We build Docker images for deploying so we can leverage any system that accept Docker image.</p>

<p>In this tutorial, we use Heroku and Kubernetes, but you can choose whatever system that Docker is supported.</p>

<p>Heroku is very easy to be used, just push the Docker image and it should work.</p>

<p>Kubernetes (K8s) and Helm is easy to work with, it&rsquo;s mature and it gives us more control over everything.
I recommend using Kubernetes for production system to automate it all.</p>

<h2>Heroku Deployment</h2>

<p>You can follow <a href="https://devcenter.heroku.com/articles/container-registry-and-runtime">https://devcenter.heroku.com/articles/container-registry-and-runtime</a> to deploy your
Docker image to Heroku.</p>

<h2>K8s Deployment</h2>

<p>You can use Google Container Engine (GKE) to deploy K8s applications. Using Helm as the K8s package
manager is more easier and convenient.</p>

<p>I created the Helm chart for this application here:
<a href="https://github.com/acme101/nextjs-hello-world/tree/develop/helm-charts/nextjs-hello-world">https://github.com/acme101/nextjs-hello-world/tree/develop/helm-charts/nextjs-hello-world</a></p>

<p>We can install it right away:</p>

<p><code>
$ helm install halm-charts/nextjs-hello-world
</code></p>

<h1>CI/CD Systems</h1>

<p>To automate all the development integration and production deployment, we use CI/CD systems. You can
use any CI/CD systems available. In this sample project, I set up for gitlab-ci and travis-ci, they
share the same steps and these steps can be applied to any other CI/CD systems.</p>

<p>A typical CI/CD system will need to:</p>

<ul>
<li><p>check for new changes</p>

<ul>
<li>code style</li>
<li>security</li>
<li>all kinds of tests</li>
</ul>
</li>
<li><p>when checks passes, build the production Docker image and push to the Docker registry</p></li>
<li><p>take the production Docker image and deploy it to the production systems</p></li>
<li><p>everyone enjoys the new changes!</p></li>
</ul>


<p>The CI/CD system should work on any forked repo, too.</p>

<p>And to get it work, we need to provide the some environment variables settings. To know more about
some of these variables, please follow:</p>

<ul>
<li><p>How to deploy on Heroku: <a href="https://github.com/acme101/dev-setup/blob/master/docs/how-to-deploy-on-heroku.md">https://github.com/acme101/dev-setup/blob/master/docs/how-to-deploy-on-heroku.md</a></p></li>
<li><p>How to deploy on GCP: <a href="https://github.com/acme101/dev-setup/blob/master/docs/how-to-deploy-on-gcp.md">https://github.com/acme101/dev-setup/blob/master/docs/how-to-deploy-on-gcp.md</a></p></li>
</ul>


<h1>Sum up</h1>

<p>In this tutorial, I&rsquo;ve introduced the development philosophy and workflow that we apply for all our
projects at Teracy and our clients' projects. I hope that it could be helpful to others to boost
your productivity with software development.</p>

<p>Happy developing!</p>
]]></content>
  </entry>
  
</feed>
